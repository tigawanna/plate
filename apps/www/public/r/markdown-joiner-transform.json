{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "markdown-joiner-transform",
  "type": "registry:hook",
  "dependencies": [
    "ai@4.3.19"
  ],
  "files": [
    {
      "path": "src/registry/lib/markdown-joiner-transform.ts",
      "content": "import type { TextStreamPart, ToolSet } from 'ai';\n\n/**\n * Transform chunks like [**,bold,**] to [**bold**] make the md deserializer\n * happy.\n *\n * @experimental\n */\nexport const markdownJoinerTransform =\n  <TOOLS extends ToolSet>() =>\n  () => {\n    const joiner = new MarkdownJoiner();\n\n    return new TransformStream<TextStreamPart<TOOLS>, TextStreamPart<TOOLS>>({\n      async flush(controller) {\n        const remaining = joiner.flush();\n        if (remaining) {\n          controller.enqueue({\n            text: remaining,\n            type: 'text-delta',\n          } as TextStreamPart<TOOLS>);\n        }\n      },\n      async transform(chunk, controller) {\n        if (chunk.type === 'text-delta') {\n          const processedText = joiner.processText(chunk.text);\n          if (processedText) {\n            controller.enqueue({\n              ...chunk,\n              text: processedText,\n            });\n            await delay(joiner.delayInMs);\n          }\n        } else {\n          controller.enqueue(chunk);\n        }\n      },\n    });\n  };\n\nconst DEFAULT_DELAY_IN_MS = 10;\nconst NEST_BLOCK_DELAY_IN_MS = 100;\n\nexport class MarkdownJoiner {\n  private buffer = '';\n  private documentCharacterCount = 0;\n  private isBuffering = false;\n  private streamingCodeBlock = false;\n  private streamingLargeDocument = false;\n  private streamingTable = false;\n  public delayInMs = DEFAULT_DELAY_IN_MS;\n\n  private clearBuffer(): void {\n    this.buffer = '';\n    this.isBuffering = false;\n  }\n  private isCompleteBold(): boolean {\n    const boldPattern = /\\*\\*.*?\\*\\*/;\n\n    return boldPattern.test(this.buffer);\n  }\n\n  private isCompleteCodeBlockEnd(): boolean {\n    return this.buffer.trimEnd() === '```';\n  }\n\n  private isCompleteCodeBlockStart(): boolean {\n    const codeLinePattern = /```[^\\s]+/;\n    return codeLinePattern.test(this.buffer);\n  }\n\n  private isCompleteLink(): boolean {\n    const linkPattern = /^\\[.*?\\]\\(.*?\\)$/;\n    return linkPattern.test(this.buffer);\n  }\n\n  private isCompleteList(): boolean {\n    const unorderedListPattern = /^[*-]\\s+.+/;\n    const todoListPattern = /^[*-]\\s+\\[[ xX]\\]\\s+.+/;\n    const orderedListPattern = /^\\d+\\.\\s+.+/;\n\n    if (unorderedListPattern.test(this.buffer) && this.buffer.includes('['))\n      return todoListPattern.test(this.buffer);\n\n    return (\n      unorderedListPattern.test(this.buffer) ||\n      orderedListPattern.test(this.buffer) ||\n      todoListPattern.test(this.buffer)\n    );\n  }\n\n  private isCompleteMdxTag(): boolean {\n    const mdxTagPattern = /<([A-Za-z][A-Za-z0-9\\-_]*)>/;\n\n    return mdxTagPattern.test(this.buffer);\n  }\n\n  private isCompleteTableStart(): boolean {\n    return this.buffer.startsWith('|') && this.buffer.endsWith('|');\n  }\n\n  private isFalsePositive(char: string): boolean {\n    // when link is not complete, even if ths buffer is more than 30 characters, it is not a false positive\n    if (this.buffer.startsWith('[') && this.buffer.includes('http')) {\n      return false;\n    }\n\n    return char === '\\n' || this.buffer.length > 30;\n  }\n\n  private isLargeDocumentStart(): boolean {\n    return this.documentCharacterCount > 2500;\n  }\n\n  private isListStartChar(char: string): boolean {\n    return char === '-' || char === '*' || /^[0-9]$/.test(char);\n  }\n\n  private isTableExisted(): boolean {\n    return this.buffer.length > 10 && !this.buffer.includes('|');\n  }\n\n  flush(): string {\n    const remaining = this.buffer;\n    this.clearBuffer();\n    return remaining;\n  }\n\n  processText(text: string): string {\n    let output = '';\n\n    for (const char of text) {\n      if (\n        this.streamingCodeBlock ||\n        this.streamingTable ||\n        this.streamingLargeDocument\n      ) {\n        this.buffer += char;\n\n        if (char === '\\n') {\n          output += this.buffer;\n          this.clearBuffer();\n        }\n\n        if (this.isCompleteCodeBlockEnd() && this.streamingCodeBlock) {\n          this.streamingCodeBlock = false;\n          this.delayInMs = DEFAULT_DELAY_IN_MS;\n\n          output += this.buffer;\n          this.clearBuffer();\n        }\n\n        if (this.isTableExisted() && this.streamingTable) {\n          this.streamingTable = false;\n          this.delayInMs = DEFAULT_DELAY_IN_MS;\n\n          output += this.buffer;\n          this.clearBuffer();\n        }\n      } else if (this.isBuffering) {\n        this.buffer += char;\n\n        if (this.isCompleteCodeBlockStart()) {\n          this.delayInMs = NEST_BLOCK_DELAY_IN_MS;\n          this.streamingCodeBlock = true;\n          continue;\n        }\n\n        if (this.isCompleteTableStart()) {\n          this.delayInMs = NEST_BLOCK_DELAY_IN_MS;\n          this.streamingTable = true;\n          continue;\n        }\n\n        if (this.isLargeDocumentStart()) {\n          this.delayInMs = NEST_BLOCK_DELAY_IN_MS;\n          this.streamingLargeDocument = true;\n          continue;\n        }\n\n        if (\n          this.isCompleteBold() ||\n          this.isCompleteMdxTag() ||\n          this.isCompleteList() ||\n          this.isCompleteLink()\n        ) {\n          output += this.buffer;\n          this.clearBuffer();\n        } else if (this.isFalsePositive(char)) {\n          // False positive - flush buffer as raw text\n          output += this.buffer;\n          this.clearBuffer();\n        }\n      } else {\n        // Check if we should start buffering\n\n        if (\n          char === '*' ||\n          char === '<' ||\n          char === '`' ||\n          char === '|' ||\n          char === '[' ||\n          this.isListStartChar(char)\n        ) {\n          this.buffer = char;\n          this.isBuffering = true;\n        } else {\n          // Pass through character directly\n          output += char;\n        }\n      }\n    }\n\n    this.documentCharacterCount += text.length;\n    return output;\n  }\n}\n\nasync function delay(delayInMs?: number | null): Promise<void> {\n  return delayInMs == null\n    ? Promise.resolve()\n    : new Promise((resolve) => setTimeout(resolve, delayInMs));\n}\n",
      "type": "registry:lib"
    }
  ]
}